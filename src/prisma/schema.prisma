generator client {
  provider = "prisma-client-js"
  seed     = "ts-node src/prisma/seed.ts"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- ENUMS ---
enum PixAddressKeyType {
  CPF
  CNPJ
  EMAIL
  PHONE
  EVP // Chave Aleatória (Endereço Virtual de Pagamento)
}

enum PropertyTransactionType {
  VENDA
  LOCACAO
}

enum UserRole {
  ADMIN
  LOCADOR
  LOCATARIO
}

enum CompanyType {
  MEI
  LIMITED
  INDIVIDUAL
  ASSOCIATION
}

enum ContractStatus {
  PENDENTE_DOCUMENTACAO
  EM_ANALISE
  AGUARDANDO_ASSINATURAS
  ATIVO
  FINALIZADO
  CANCELADO
}

enum PropertyType {
  APARTAMENTO
  APARTAMENTO_DUPLEX
  APARTAMENTO_TRIPLEX
  CASA
  CHACARA
  KITNET
  LOJA_SALA
  PREDIO
  TERRENO
}

enum PdfType {
  CONTRATO_LOCACAO
  RELATORIO_JUDICIAL
}

enum GuaranteeType {
  DEPOSITO_CAUCAO
  FIADOR
  SEGURO_FIANCA
  SEM_GARANTIA
}

enum DocumentType {
  IDENTIDADE_FRENTE
  IDENTIDADE_VERSO
  CPF
  COMPROVANTE_RENDA
  COMPROVANTE_ENDERECO
}

enum DocumentStatus {
  REPROVADO
  AGUARDANDO_APROVACAO
  APROVADO
}

enum PaymentStatus {
  PENDENTE
  PAGO
  ATRASADO
  ISENTO
  CONFIRMADO
  FALHOU
  CANCELADO
  EM_REPASSE
  RECEBIDO
}

enum TransferStatus {
  PENDING
  DONE
  FAILED
  CANCELLED
}

enum SignatureStatus {
  PENDING
  STARTED
  SIGNED
  CLOSED
  REFUSED
  UPLOADED
}

enum InterestStatus {
  PENDING // Interessado enviou, aguardando ação do locador
  CONTACTED // Locador marcou que já entrou em contato
  DISMISSED // Locador dispensou o interesse
}

// --- MODELS ---

model User {
  id                 String   @id @default(uuid())
  name               String
  email              String   @unique
  password           String
  cpfCnpj            String   @unique
  phone              String
  role               UserRole @default(LOCATARIO)
  status             Boolean  @default(true)
  emailVerified      Boolean  @default(false)
  isTwoFactorEnabled Boolean  @default(false)
  preferences        Json?
  asaasCustomerId    String?  @unique

  emailVerificationToken       String?   @unique
  emailVerificationTokenExpiry DateTime?

  resetToken       String?   @unique
  resetTokenExpiry DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  birthDate   DateTime?    @db.Date
  companyType CompanyType?
  incomeValue Decimal?

  cep        String?
  street     String?
  number     String?
  city       String?
  state      String?
  province   String?
  complement String?

  condominiums        Condominium[]      @relation("LandlordCondominiums")
  propertiesOwned     Property[]         @relation("LandlordProperties")
  contractsAsLandlord Contract[]         @relation("LandlordContracts")
  contractsAsTenant   Contract[]         @relation("TenantContracts")
  logs                Log[]
  // webhooks            Webhook[]
  bankAccount         BankAccount?
  subAccount          SubAccount?
  asaasCustomers      AsaasCustomer[]    @relation("TenantAsaasCustomers")
  signatureRequests   SignatureRequest[]
  transfers           Transfer[]
  interestsAsTenant   Interest[]         @relation("InterestsAsTenant")
  interestsAsLandlord Interest[]         @relation("InterestsAsLandlord")
}

model SubAccount {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  asaasWalletId     String? @unique
  asaasAccountId    String  @unique
  apiKey            String
  asaasWebhookToken String? @unique

  onboardingUrl         String?
  statusGeneral         String? // 'APPROVED', 'PENDING'
  statusDocumentation   String?
  statusCommercialInfo  String?
  statusBankAccountInfo String?
  platformFeePercentage Decimal?        @default(5.0)
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  AsaasCustomer         AsaasCustomer[]
}

model AsaasCustomer {
  id              String @id @default(uuid())
  tenantId        String
  subaccountId    String
  asaasCustomerId String @unique

  tenant     User       @relation("TenantAsaasCustomers", fields: [tenantId], references: [id])
  subAccount SubAccount @relation(fields: [subaccountId], references: [id])

  createdAt DateTime @default(now())

  @@unique([tenantId, subaccountId])
}

model BankAccount {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  // Campos exclusivos para PIX
  pixAddressKey     String
  pixAddressKeyType PixAddressKeyType

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// model Webhook {
//   id         String   @id @default(uuid())
//   name       String
//   url        String
//   email      String
//   sendType   String
//   apiVersion Int      @default(3)
//   authToken  String?
//   enabled    Boolean  @default(true)
//   events     String[]
//   userId     String
//   user       User     @relation(fields: [userId], references: [id])
// }

model Condominium {
  id   String @id @default(uuid())
  name String

  cep      String
  street   String
  number   String
  district String
  city     String
  state    String

  landlordId String
  landlord   User   @relation("LandlordCondominiums", fields: [landlordId], references: [id])

  properties Property[]
}

model Property {
  id              String                  @id @default(uuid())
  title           String
  description     String?                 @db.Text
  transactionType PropertyTransactionType @default(LOCACAO)
  value           Decimal
  propertyType    PropertyType

  cep      String?
  street   String?
  district String?
  city     String?
  state    String?

  number     String
  complement String?

  areaInM2     Float
  numRooms     Int     @default(0)
  numBathrooms Int     @default(0)
  numParking   Int     @default(0)
  isAvailable  Boolean @default(true)

  condominiumId String?
  condominium   Condominium? @relation(fields: [condominiumId], references: [id], onDelete: Cascade)

  landlordId String
  landlord   User   @relation("LandlordProperties", fields: [landlordId], references: [id])

  contracts Contract[]
  photos    Photo[]

  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  Interest  Interest[]

  @@index([title, street, district, city, state, cep], name: "property_search_idx")
  @@index([landlordId])
}

model Contract {
  id               String         @id @default(uuid())
  status           ContractStatus @default(PENDENTE_DOCUMENTACAO)
  rentAmount       Decimal
  condoFee         Decimal?
  iptuFee          Decimal?
  startDate        DateTime
  endDate          DateTime
  durationInMonths Int
  guaranteeType    GuaranteeType  @default(SEM_GARANTIA)
  securityDeposit  Decimal?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  propertyId String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  landlordId String
  landlord   User   @relation("LandlordContracts", fields: [landlordId], references: [id])

  tenantId String
  tenant   User   @relation("TenantContracts", fields: [tenantId], references: [id])

  paymentsOrders PaymentOrder[]
  documents      Document[]
  GeneratedPdf   GeneratedPdf[]
}

model GeneratedPdf {
  id                  String             @id @default(uuid())
  filePath            String
  pdfType             PdfType
  generatedAt         DateTime
  signedFilePath      String?
  clicksignEnvelopeId String?            @unique
  contractId          String
  contract            Contract           @relation(fields: [contractId], references: [id])
  signatureRequests   SignatureRequest[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model SignatureRequest {
  id                  String          @id @default(uuid())
  clicksignSignerId   String          @unique
  clicksignDocumentId String?
  clicksignEnvelopeId String?
  status              SignatureStatus @default(PENDING)
  signedAt            DateTime?
  closedAt            DateTime?
  finalPdfUrl         String?

  generatedPdfId String
  generatedPdf   GeneratedPdf @relation(fields: [generatedPdfId], references: [id], onDelete: Cascade)

  signerId String
  user     User   @relation(fields: [signerId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([clicksignDocumentId])
  @@index([clicksignEnvelopeId])
}

model PaymentOrder {
  id           String         @id @default(uuid())
  contractId   String
  amountDue    Decimal
  amountPaid   Decimal?
  netValue     Decimal?
  dueDate      DateTime       @default(now()) @db.Date
  paidAt       DateTime?      @db.Date
  status       PaymentStatus  @default(PENDENTE)
  contract     Contract       @relation(fields: [contractId], references: [id], onDelete: Cascade)
  bankSlip     BankSlip?
  transfer     Transfer?
  PaymentSplit PaymentSplit[]
}

model Transfer {
  id              String         @id @default(uuid())
  asaasTransferId String?        @unique
  paymentOrderId  String?        @unique
  paymentOrder    PaymentOrder?  @relation(fields: [paymentOrderId], references: [id], onDelete: Cascade)
  status          TransferStatus @default(PENDING)
  value           Decimal
  effectiveDate   DateTime?
  failReason      String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id])
}

model PaymentSplit {
  id        String  @id @default(uuid())
  paymentId String
  recipient String // subconta destino (ex: asaasWalletId ou id da plataforma)
  amount    Decimal
  type      String // FIXED ou PERCENTUAL

  payment PaymentOrder @relation(fields: [paymentId], references: [id], onDelete: Cascade)
}

model BankSlip {
  id                    String       @id @default(uuid())
  paymentOrderId        String       @unique
  asaasChargeId         String       @unique
  dueDate               DateTime     @db.Date
  bankSlipUrl           String
  transactionReceiptUrl String?
  invoiceUrl            String
  nossoNumero           String
  createdAt             DateTime     @default(now())
  updatedAt             DateTime     @updatedAt
  paymentOrder          PaymentOrder @relation(fields: [paymentOrderId], references: [id], onDelete: Cascade)
}

model Photo {
  id         String   @id @default(uuid())
  filePath   String
  name       String?
  isCover    Boolean  @default(false)
  propertyId String
  property   Property @relation(fields: [propertyId], references: [id])
}

model Document {
  id         String         @id @default(uuid())
  type       DocumentType
  filePath   String
  status     DocumentStatus @default(AGUARDANDO_APROVACAO)
  contractId String
  contract   Contract       @relation(fields: [contractId], references: [id], onDelete: Cascade)
  uploadedAt DateTime       @default(now())
}

model Log {
  id        String   @id @default(uuid())
  userId    String
  action    String
  targetId  String
  tableName String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model Interest {
  id              String         @id @default(uuid())
  message         String?        @db.Text
  status          InterestStatus @default(PENDING)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  dismissalReason String?        @db.Text

  propertyId String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  tenantId String
  tenant   User   @relation("InterestsAsTenant", fields: [tenantId], references: [id], onDelete: Cascade)

  landlordId String
  landlord   User   @relation("InterestsAsLandlord", fields: [landlordId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([landlordId])
}
